{
  "ok": 1,
  "branch": "default",
  "modules": {
    "main": "// Notes:\n//  - need to prioritise harvester respawning - DONE\n//  - need to suspend spending energy (e.g. building) when needing spawn - DONE\n//  - need to direct additional upgraders to other sources, if source is blocked\n//  - display some metrics periodically (e.g. upgrade rate, harvest rate, CPU time per creep)\n\nvar errors = require('errors');\n\nvar roles = {\n    'harvester' : require('role.harvester'),\n    'upgrader'  : require('role.upgrader'),\n    'upgrader2' : require('role.upgrader2'),\n    'builder'   : require('role.builder'),\n    'repairer'  : require('role.repairer'),\n    'miner'     : require('role.miner'),\n};\n\nvar roster = {\n    'harvester' : { 'max': 3, 'body': [ WORK, WORK,  CARRY, CARRY, CARRY, CARRY, MOVE,  MOVE,  MOVE,  MOVE ] },\n    'upgrader'  : { 'max': 2, 'body': [ WORK, WORK,  WORK,  WORK,  CARRY, CARRY, MOVE,  MOVE ] },\n    'upgrader2' : { 'max': 2, 'body': [ WORK, WORK,  WORK,  WORK,  CARRY, CARRY, CARRY, MOVE,  MOVE,  MOVE ] },\n    'builder'   : { 'max': 1, 'body': [ WORK, WORK,  CARRY, CARRY, MOVE,  MOVE ] },\n    'repairer'  : { 'max': 2, 'body': [ WORK, WORK,  CARRY, CARRY, MOVE,  MOVE,  MOVE,  MOVE ] },\n    'miner'     : { 'max': 0, 'body': [ WORK, CARRY, MOVE ] },\n};\n\nglobal.roster = roster;\n\nglobal.creep_info = function(creep) {\n    return creep.name + ': ticks ' + creep.ticksToLive + ', hits ' + creep.hits + ', fatigue ' + creep.fatigue;\n}\n\nglobal.role_info = function(role) {\n    var members = _.filter(Game.creeps, (creep) => creep.memory.role == role);\n    result = role.substr(0,1).toUpperCase() + role.substr(1) + 's :\\n';\n    for (var i in members) {\n        result += '  ' + creep_info(members[i]) + '\\n';\n    }\n    return result;\n}\n\nglobal.who = function() {\n    for (var role in roles) {\n        console.log(role_info(role));\n    }\n}\n\nglobal.spawn_creep = function(role, body) {\n    var newName = Game.spawns.Spawn1.createCreep(body, undefined, {role: role});\n    if (newName === parseInt(newName, 10)) {\n        console.log('Deferring spawn of new ' + role + ' (' + errors.error2string(newName) + ')');\n        newName = undefined;\n    } else {\n        console.log('Spawning new ' + role + ': ' + newName);\n    }\n    return newName;\n}\n\nglobal.spawn_roster = function(roster) {\n    for (var role in roster) {\n        var members = _.filter(Game.creeps, (creep) => creep.memory.role == role);\n        if (members.length < roster[role].max) {\n            var name = spawn_creep(role, roster[role].body);\n            // only ever attempt to spawn one at a time, or earlier spawns get obliterated!\n            break;\n        }\n    }\n}\n\nglobal.is_roster_met = function(roster, report=true) {\n    var met = true;\n    for (var role in roster) {\n        var members = _.filter(Game.creeps, (creep) => creep.memory.role == role);\n        if (members.length < roster[role].max) {\n            if (report) { console.log(role + ': have ' + members.length + ', need ' + roster[role].max); }\n            met = false;\n        }\n    }\n    return met;\n}    \n\nglobal.suspend_role = function(role, suspend) {\n    var members = _.filter(Game.creeps, (creep) => creep.memory.role == role);\n    for (var i in members) {\n        members[i].memory.suspend = suspend;            \n    }\n}\n\nglobal.manage_energy = function(roster) {\n    // if roster is unmet (and energy is low?), pause energy spending (i.e. builders)\n    var suspend_spending = !is_roster_met(roster, false);\n    if (suspend_spending) {\n        console.log(\"Unmet roster - suspending energy spending\");\n    }\n    suspend_role('builder', suspend_spending);\n    suspend_role('repairer', suspend_spending);\n    suspend_role('upgrader2', suspend_spending);\n}\n\nmodule.exports.loop = function () {\n\n    var mainStartCpu = Game.cpu.getUsed();\n\n    // Memory cleanup, must be first:\n    for (var name in Memory.creeps) {\n        if (!Game.creeps[name]) {\n            delete Memory.creeps[name];\n        }\n    }\n\n    // pause creeps if energy is low\n    manage_energy(roster);\n\n    // maintain creep roster:\n    spawn_roster(roster);\n\n    // Tower control\n    var tower = Game.getObjectById('57695bf17f3ecf055422ddad');\n    if (tower) {\n        var closestDamagedStructure = tower.pos.findClosestByRange(FIND_STRUCTURES, {\n            // don't repair walls and roads at the moment:\n            filter: (structure) => structure.hits < structure.hitsMax &&\n                structure.structureType != STRUCTURE_WALL &&\n                structure.structureType != STRUCTURE_ROAD\n        });\n        console.log('ClosestDamagedStructure: ' + closestDamagedStructure);\n        if (closestDamagedStructure) {\n            tower.repair(closestDamagedStructure);\n        }\n\n        var closestHostile = tower.pos.findClosestByRange(FIND_HOSTILE_CREEPS);\n        if (closestHostile) {\n            tower.attack(closestHostile);\n        }\n    }\n\n    var mainElapsed = Game.cpu.getUsed() - mainStartCpu;\n    console.log('Main has used ' + mainElapsed.toFixed(2) + ' CPU time');\n\n    // Role execution\n    for(var name in Game.creeps) {\n        var creep = Game.creeps[name];\n        for (var role in roles) {\n            if (creep.memory.role == role) {\n                var creepStartCpu = Game.cpu.getUsed();\n                roles[role].run(creep);\n                var creepElapsed = Game.cpu.getUsed() - creepStartCpu;\n                console.log('  ' + name + ' has used ' + creepElapsed.toFixed(2) + ' CPU time');\n            }\n        }\n    }\n    \n    var totalElapsed = Game.cpu.getUsed() - mainStartCpu;\n    console.log('Total CPU time: ' + totalElapsed.toFixed(2));\n}",
    "errors": "// Convert error codes to strings\n\nvar errorMap = {\n    '0':   'OK',\n    '-1':  'ERR_NOT_OWNER',\n    '-2':  'ERR_NO_PATH',\n    '-3':  'ERR_NAME_EXISTS',\n    '-4':  'ERR_BUSY',\n    '-5':  'ERR_NOT_FOUND',\n    '-6':  'ERR_NOT_ENOUGH...',\n    '-7':  'ERR_INVALID_TARGET',\n    '-8':  'ERR_FULL',\n    '-9':  'ERR_NOT_IN_RANGE',\n    '-10': 'ERR_INVALID_ARGS',\n    '-11': 'ERR_TIRED',\n    '-12': 'ERR_NO_BODYPART',\n    '-14': 'ERR_RCL_NOT_ENOUGH',\n    '-15': 'ERR_GCL_NOT_ENOUGH',\n};\n\nmodule.exports = {\n\n    error2string: function(code) {\n        return errorMap[code];\n    },\n\n    test: function() {\n       console.log(errorMap[Game.ERR_FULL]);\n    }\n\n};\n",
    "role.harvester": "var roleHarvester = {\n\n    /** @param {Creep} creep **/\n    run: function(creep) {\n        \n        if (!creep.memory.harvesting && creep.carry.energy == 0) {\n            creep.memory.harvesting = true;\n            console.log(creep.name + ' now harvesting');\n        }\n        if (creep.memory.harvesting && creep.carry.energy == creep.carryCapacity) {\n            creep.memory.harvesting = false;\n            console.log(creep.name + ' now delivering');\n        }\n        \n        if (creep.memory.harvesting) {\n            //console.log(creep.name + ' harvesting');\n            var sources = creep.room.find(FIND_SOURCES);\n            if (creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) {\n                //console.log(creep.name + ' going to ' + sources[0]);\n                creep.moveTo(sources[0]);\n            }\n        } else {\n            //console.log(creep.name + ' delivering');\n            var targets = creep.room.find(FIND_STRUCTURES, {\n                filter: (structure) => {\n                    return (structure.structureType == STRUCTURE_EXTENSION ||\n                        structure.structureType == STRUCTURE_SPAWN ||\n                        structure.structureType == STRUCTURE_TOWER) && structure.energy < structure.energyCapacity;\n                }\n            });\n            if (targets.length > 0) {\n                //TODO: search for tower, put at front of list\n                if(creep.transfer(targets[0], RESOURCE_ENERGY) == ERR_NOT_IN_RANGE) {\n                    //console.log(creep.name + ' going to ' + targets[0]);\n                    creep.moveTo(targets[0]);\n                }\n            } else {\n                // nowhere to deliver, so move away from Source to avoid blocking it\n                //console.log(creep.name + ' going to rally');\n                creep.moveTo(Game.flags.rally);\n            }\n        }\n\t}\n};\n\nmodule.exports = roleHarvester;\n\n\n    \t   // if(creep.carry.energy < creep.carryCapacity) {\n        //         var sources = creep.room.find(FIND_SOURCES);\n        //         if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) {\n        //             creep.moveTo(sources[0]);\n        //         }\n        //     }\n        //     else {\n        //         var targets = creep.room.find(FIND_STRUCTURES, {\n        //                 filter: (structure) => {\n        //                     return (structure.structureType == STRUCTURE_EXTENSION ||\n        //                             structure.structureType == STRUCTURE_SPAWN ||\n        //                             structure.structureType == STRUCTURE_TOWER) && structure.energy < structure.energyCapacity;\n        //                 }\n        //         });\n        //         if(targets.length > 0) {\n        //             if(creep.transfer(targets[0], RESOURCE_ENERGY) == ERR_NOT_IN_RANGE) {\n        //                 creep.moveTo(targets[0]);\n        //             }\n        //         } else {\n        //             // move away from Source\n        //             creep.moveTo(Game.spawns.Spawn1);\n        //         }\n        //     }\n",
    "role.upgrader": "var roleUpgrader = {\n\n    /** @param {Creep} creep **/\n    run: function(creep) {\n\n        if (creep.memory.upgrading && creep.carry.energy == 0) {\n            creep.memory.upgrading = false;\n        }        \n        if (!creep.memory.upgrading && creep.carry.energy == creep.carryCapacity) {\n            creep.memory.upgrading = true;\n        }\n\n        if (creep.memory.upgrading) {\n            if (creep.upgradeController(creep.room.controller) == ERR_NOT_IN_RANGE) {\n                creep.moveTo(creep.room.controller);\n            }\n        } else {\n            if (creep.carry.energy < creep.carryCapacity) {\n                var sources = creep.room.find(FIND_SOURCES);\n                // go to the second source\n                if (creep.harvest(sources[1]) == ERR_NOT_IN_RANGE) {\n                    creep.moveTo(sources[1]);\n                }\n            }\n        }\n    }\n};\n\nmodule.exports = roleUpgrader;",
    "role.builder": "var roleBuilder = {\n\n    /** @param {Creep} creep **/\n    run: function(creep) {\n\n        if (creep.memory.suspend) {\n            creep.moveTo(Game.flags.rally);\n            return;\n        }\n\n        if(creep.memory.building && creep.carry.energy == 0) {\n            creep.memory.building = false;\n        }\n        if(!creep.memory.building && creep.carry.energy == creep.carryCapacity) {\n            creep.memory.building = true;\n        }\n\n        if(creep.memory.building) {\n            var targets = creep.room.find(FIND_CONSTRUCTION_SITES);\n            if(targets.length) {\n                if(creep.build(targets[0]) == ERR_NOT_IN_RANGE) {\n                    creep.moveTo(targets[0]);\n                }\n            } else {\n                // wait near Spawn1\n                creep.moveTo(Game.spawns.Spawn1);\n            }\n        }\n        else {\n            var sources = creep.room.find(FIND_SOURCES);\n            // if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) {\n            //     creep.moveTo(sources[0]);\n            // }\n            // go to the Spawn1 for energy\n            if (Game.spawns.Spawn1.transferEnergy(creep) == ERR_NOT_IN_RANGE) {\n                creep.moveTo(Game.spawns.Spawn1);\n            }\n        }\n    }\n};\n\nmodule.exports = roleBuilder;",
    "role.repairer": "var roleRepairer = {\n\n    /** @param {Creep} creep **/\n    run: function(creep) {\n\n        if (creep.memory.suspend) {\n            creep.moveTo(Game.flags.rally);\n            return;\n        }\n\n        if(creep.memory.repairing && creep.carry.energy == 0) {\n            creep.memory.repairing = false;\n        }\n        if(!creep.memory.repairing && creep.carry.energy == creep.carryCapacity) {\n            creep.memory.repairing = true;\n        }\n\n        if (creep.memory.repairing) {\n            var targets = creep.room.find(FIND_STRUCTURES, {\n                filter: object => object.hits < object.hitsMax\n            });\n\n            targets.sort((a,b) => a.hits - b.hits);\n\n            if (targets.length > 0) {\n                if(creep.repair(targets[0]) == ERR_NOT_IN_RANGE) {\n                    creep.moveTo(targets[0]);    \n                }\n            } else {\n                // wait near Spawn1\n                creep.moveTo(Game.spawns.Spawn1);\n            }\n        } else {\n            var sources = creep.room.find(FIND_SOURCES);\n            // go to the second source \n//            if(creep.harvest(sources[1]) == ERR_NOT_IN_RANGE) {\n//                creep.moveTo(sources[1]);\n//            }\n            // go to the Spawn1 for energy\n            if(Game.spawns.Spawn1.transferEnergy(creep) == ERR_NOT_IN_RANGE) {\n                creep.moveTo(Game.spawns.Spawn1);\n            }\n        }\n    }\n};\n\nmodule.exports = roleRepairer;",
    "role.miner": "var roleMiner = {\n\n    /** @param {Creep} creep **/\n    run: function(creep) {\n\t    if (_.sum(creep.carry) < creep.carryCapacity) {\n            var sources = creep.room.find(FIND_MINERALS);\n            if (creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) {\n                creep.moveTo(sources[0]);\n            }\n        } else {\n            if (creep.transfer(Game.spawns.Spawn1, RESOURCES_ALL) == ERR_NOT_IN_RANGE) {\n                creep.moveTo(Game.spawns.Spawn1);\n            }\n        }\n\t}\n};\n\nmodule.exports = roleMiner;\n",
    "role.demolisher": null,
    "role.upgrader2": "// This role is similar to roleUpgrader, except that it returns to the Spawn for energy\nvar roleUpgrader2 = {\n\n    /** @param {Creep} creep **/\n    run: function(creep) {\n\n        if (creep.memory.suspend) {\n            creep.moveTo(Game.flags.rally);\n            return;\n        }\n\n        if (creep.memory.upgrading && creep.carry.energy == 0) {\n            creep.memory.upgrading = false;\n        }        \n        if (!creep.memory.upgrading && creep.carry.energy == creep.carryCapacity) {\n            creep.memory.upgrading = true;\n        }\n\n        if (creep.memory.upgrading) {\n            if (creep.upgradeController(creep.room.controller) == ERR_NOT_IN_RANGE) {\n                creep.moveTo(creep.room.controller);\n            }\n        } else {\n            if (creep.carry.energy < creep.carryCapacity) {\n                var spawns = creep.room.find(FIND_MY_SPAWNS);\n                // go to the first Spawn\n                if (spawns[0].transferEnergy(creep) == ERR_NOT_IN_RANGE) {\n                    creep.moveTo(spawns[0]);\n                }\n            }\n        }\n    }\n};\n\nmodule.exports = roleUpgrader2;"
  }
}
